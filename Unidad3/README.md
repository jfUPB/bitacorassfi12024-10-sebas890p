# Bitácora de aprendizaje

## ¿Cómo voy?

- [x] Tengo mi reto personalizado. 
- [x] Terminé la actividad 1 de investigar. 
- [x] Terminé la actividad 2 de investigar.
- [x] Terminé la actividad 3 de investigar.
- [x] Terminé la actividad 4 de investigar.
- [x] Terminé la actividad 5 de investigar.
- [ ] Terminé la fase de aplicar.
- [ ] Terminé la documentación de cierre.

## Reto personalizado
> [!TIP]
> Escribe aquí tu reto personalizado. 

## Documentación de cierre de la unidad

### ¿En qué consiste la aplicación que diseñaste e implementaste?

### Explica el protocolo de integración entre p5.js y el micro:bit.

### Muestra las partes del código donde implementaste el protocolo.

### Enlace al video demostrativo




## Consejos para el uso efectivo de la bitácora

* Preparación al inicio de la micro-sesión 1: establece un objetivo claro de la sesión para maximizar el tiempo de trabajo efectivo.
* Concisión: sé breve pero significativo en tus respuestas para ajustarte al tiempo de reflexión de 4 minutos.
* Pausas activas: usa las pausas de 1 minutos para realmente desconectar, estirar y descansar los ojos; esto ayuda a mantener la energía y la concentración.
* Reflexión profunda al final de la mimcro-sesión 4: usa parte del tiempo para una reflexión más profunda y para planificar, asegurándote de cerrar la sesión
  con una nota productiva y prepararte para lo que sigue.

## Semana 10

### Sesión 1

#### Micro-sesión 1 (25 minutos)

**Planeación:**

1. ¿Qué voy a trabajar hoy?

En esta sesion me voy a dedicar a leer a fondo esta nueva unidad y si me queda tiempo empezar con la actividad 1 
   
2. ¿Cuál es mi objetivo principal para esta sesión?

Mi objetivo en esta sesion es entender esta nueva unidad a fondo.


**Trabajo en concentración**

**Meta-aprendizaje:**

3. ¿Qué he logrado en esta micro-sesión de trabajo?

En esta sesion logre entender un poco mas de lo que se tratara esta unidad para eso parti de la siguiente pregunta que siento que resume mucho la unidad:

¿Cómo conectar el mundo físicos con mundos virtuales mediante la construcción de aplicaciones interactivas?

Conectar el mundo físico con los mundos virtuales es un proceso que implica la combinación de tecnologías como la realidad aumentada (RA), la realidad virtual (RV), Internet de las cosas (IoT), sensores y aplicaciones interactivas. Aquí hay algunos pasos generales para lograr esta conexión:

Identificar el propósito y la audiencia: Antes de comenzar a construir, es importante comprender por qué estás conectando estos mundos y para quién. ¿Es para entretenimiento, educación, marketing, entrenamiento, o alguna otra aplicación?

Seleccionar la tecnología adecuada: Dependiendo de tus necesidades y recursos, deberás elegir las tecnologías más adecuadas. Por ejemplo, si deseas una experiencia inmersiva, la realidad virtual puede ser la opción correcta. Si buscas una integración con el mundo físico, la realidad aumentada o el IoT pueden ser más apropiados.

Desarrollar aplicaciones interactivas: Utiliza herramientas de desarrollo de software y diseño para crear aplicaciones interactivas. Estas aplicaciones pueden variar desde simples hasta complejas, dependiendo de la experiencia que desees proporcionar a los usuarios.

Integrar tecnologías de realidad aumentada y realidad virtual: Si estás utilizando RA o RV, asegúrate de integrar estas tecnologías de manera efectiva en tu aplicación interactiva. Esto puede implicar el uso de SDKs (kits de desarrollo de software) proporcionados por plataformas como ARKit, ARCore o Unity para RA, y dispositivos de RV como Oculus Rift, HTC Vive, o dispositivos móviles con soporte para RV.

Conectar dispositivos físicos: Si estás utilizando IoT o sensores para conectar el mundo físico, asegúrate de que estén correctamente configurados y conectados a tu aplicación interactiva. Esto puede requerir el uso de protocolos de comunicación como MQTT, CoAP o HTTP, según las necesidades de tu proyecto.

Pruebas y refinamiento: Una vez que hayas construido la aplicación, realiza pruebas exhaustivas para asegurarte de que funcione correctamente y proporciona la experiencia deseada. Recopila comentarios de los usuarios y realiza ajustes según sea necesario.

Despliegue y mantenimiento: Una vez que la aplicación esté lista, despliégala en la plataforma deseada (por ejemplo, tiendas de aplicaciones móviles, plataformas de RV, etc.). Asegúrate de mantenerla actualizada y solucionar cualquier problema que surja.


4. ¿Con qué dificultades me encontré y cómo las abordé?

Estuve buscando respuestas en google para la pregunta pero no sentia que encontraba la adecuada por lo que lo solucione pregutandole a chat gpt

5. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

Si, ya que encontre una respuesta donde define varios puntos de como conectar el mundo virtual con el fisico
   
6. ¿Qué he aprendido o reforzado en esta micro-sesión?

Que hay muchas formas de conectar el mundo fisico con el virtual no solo cn micro controladores. 

   

#### Micro-sesión 2 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

En esta micro sesion logre investigar y asiaprender un poco sobre los protocolos binarios de comunicacion que son los siguientes:

Los protocolos binarios para la integración de dispositivos periféricos a aplicaciones interactivas son conjuntos de reglas y estructuras de datos que definen cómo se comunican los dispositivos periféricos con las aplicaciones de software de manera eficiente y rápida. Estos protocolos utilizan representaciones binarias de datos en lugar de texto, lo que resulta en una comunicación más compacta y rápida, especialmente útil cuando se trabaja con grandes volúmenes de datos o se requieren tiempos de respuesta rápidos.

Algunos ejemplos de protocolos binarios utilizados para la integración de dispositivos periféricos incluyen:

Protocolo Binario de Enlace de Dispositivos (Bluetooth): Utilizado para la comunicación inalámbrica entre dispositivos Bluetooth, este protocolo define cómo se empaquetan y transmiten los datos binarios entre dispositivos, lo que permite la interacción fluida entre dispositivos periféricos y aplicaciones interactivas.

USB HID (Human Interface Device): Este protocolo binario se utiliza para dispositivos de interfaz humana, como teclados, ratones, gamepads, etc. Define cómo estos dispositivos se comunican con las computadoras host a través de conexiones USB, lo que permite una integración eficiente en aplicaciones interactivas.

Protocolo binario de comunicación serie (RS-232, RS-485, etc.): Estos protocolos binarios se utilizan para la comunicación serie entre dispositivos, como sensores, actuadores, controladores, etc. Definen cómo se empaquetan y transmiten los datos binarios a través de conexiones serie, permitiendo la integración de dispositivos periféricos en aplicaciones interactivas.

Protocolo binario de red (por ejemplo, TCP/IP, UDP): Aunque estos protocolos también pueden admitir datos en formato de texto, a menudo se utilizan en su forma binaria para una comunicación más eficiente entre dispositivos en red. Permiten la comunicación entre dispositivos periféricos y aplicaciones interactivas a través de redes locales o globales.


2. ¿Con qué dificultades me encontré y cómo las abordé?

Tuve la misma dificultad de la micro sesion anterior que en google no salia la informacion que necesitaba o adecuada y lo resolvi preguntale a chatgpt 


3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

Si, ya que aprendi cuales son las diferentes comunicaciones usando protocolos binarios. 

4. ¿Qué he aprendido o reforzado en esta micro-sesión?

Aprendi a sobre los protocolos biarios y a que usaremos los protocolos de serie para la comunicacion entre dispositivos. 


#### Micro-sesión 3 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

En esta micro sesion estuve viendo referencias sobre proyectos en p5.js para guiarme sobre que proyecto realizar para el reto final, me intereso y pienso partir de este proyecto:

https://makeabilitylab.github.io/physcomp/communication/p5js-serial.html





2. ¿Con qué dificultades me encontré y cómo las abordé?

La mayor dificultad de esta micro sesion fue pensar en que proyecto escoger pero lo resolvi viendo varias referencias de proyectos. 

3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

Si, estoy mas cerca porque ya escogi o tengo una idea de que proyecto realizar.

4. ¿Qué he aprendido o reforzado en esta micro-sesión?

En esta micro sesion aprendi un poco de como funciona este proyecto para asi implentarlo con las restricciones requeridas. 


#### Micro-sesión 4. (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

Partiendo de este proyecto: https://editor.p5js.org/jonfroehlich/sketches/fja8NHOKO

Logre en esta microsesion personalizar el proyecto final, el cual tendra la misma funcion de dibujar pero ira conectado con el microbit usando 2 sensores distintos que seran el acelerometro y los pulsadores.

con el acelerometro podre dibujar moviendo el microbit y con los pulsadores cambiar de color.

y usare dos actuadores que seran los leds, para mostrar que color se esta dibujando y el buzzer para reproducir un sonido mientras se dibuje. 


2. ¿Con qué dificultades me encontré y cómo las abordé?

Las principales dificultades fueron pensar que cambiar o añadir de acuerdo a las restricciones. 
tambien buscar la funcion de todos los pulsadores y actuaderos del microbit que mas que ser una dificultad era algo que queria tener claro.



3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

Si, estoy mas cerca porque ya tengo mi reto personalizado.


4. ¿Qué he aprendido o reforzado en esta micro-sesión?

En esta sesion mas que aprender, aclare las funciones completas del microbit.



**Cierre de sesión:**

5. ¿He alcanzado los objetivos planteados al inicio? Si no, ¿por qué y qué puedo mejorar?

Si, alcance el objetivo, puedo mejorar un poco en concentrarme mas al momento de hacerlo. 

6. ¿Cuáles fueron los desafíos más significativos de hoy y cómo los superé?

Realmente esta sesion no hubo un desafio grande ya que mas que todo era investigacion

7. Basado en el trabajo de hoy, ¿qué insights importantes he ganado?

Haber dejado varios conceptos claros.

8. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

Debo seguir con las actividades y a la vez investigando y analizando los problemas. 


### Sesión 2

#### Micro-sesión 1 (25 minutos)

**Planeación:**

1. ¿Qué voy a trabajar hoy?

En esta sesion tengo planeado trabajar en las actividades que pueda 


2. ¿Cuál es mi objetivo principal para esta sesión?

Mi objetivo es analizar y completar las actividades para asi entender mejor la comunicacion binaria. 



**Trabajo en concentración**

**Meta-aprendizaje:**

3. ¿Qué he logrado en esta micro-sesión de trabajo?

En esta microsesion hice el analizis de la actividad 2 lo cual le pedi a chatgpt que me explicara el codigo, el cual me dio la siguiente explicacion:

El código que has proporcionado utiliza la biblioteca struct de Python para empaquetar tres números de punto flotante (s1, s2, s3) en una secuencia de bytes, utilizando el formato big-endian (>) y el formato de representación de punto flotante (f). Luego, convierte estos bytes en una lista de números enteros y una lista de cadenas hexadecimales correspondientes a esos números enteros.


y respondi a la siguiente pregunta:


¿Qué conclusión puedes sacar hasta este punto? Escribe tu análisis en la bitácora.

La conclusión hasta este punto es que los valores de hexinfo deberian representar la forma en que los números de punto flotante son representados en la memoria de la computadora en formato hexadecimal despues de ser empaquetados por struct.pack(). Comparando estos valores hexadecimales con los obtenidos al ingresar los números en el campo Decimal Representation del sitio web, observo como los numeros de punto flotante se representan internamente en memoria en formato hexadecimal y cómo este proceso puede variar según la implementación o arquitectura de la computadora.



4. ¿Con qué dificultades me encontré y cómo las abordé?

la mayor dificultad fue entender bien el codigo por lo que le pedi a chatgpt que me lo edxplicara


5. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?


Si, porque realizar las actividades me ayuda a acercarme al objetivo


6. ¿Qué he aprendido o reforzado en esta micro-sesión?

Aprendi varios conceptos que se encuentran en el codigo como por ejemplo el formato big-endian


#### Micro-sesión 2 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

En esta micro sesion trabaje en esta pregunta 
Nota en la línea data = struct.pack('>3f',s1,s2,s3) el signo >. Repite todos los pasos anteriores pero esta vez cambia > por <. ¿Qué conclusión sacas hasta ahora.

Al cambiar el signo > por < en la línea data = struct.pack('<3f', s1, s2, s3), estamos indicando que queremos utilizar el formato little-endian en lugar de big-endian para empaquetar los números de punto flotante.

La conclusión hasta este punto es que el formato de empaquetamiento (big-endian o little-endian) afecta cómo se almacenan los bytes en la memoria de la computadora, lo que puede tener implicaciones en la forma en que se interpretan los datos y cómo se realizan las operaciones con ellos, ya que note que cada signo almacena los datos en un orden diferente, por lo que pude observar un signo los ordena de mayor a menor y el otro de menor a mayor.

2. ¿Con qué dificultades me encontré y cómo las abordé?

Realmenta no tuve alguna dificultad grande, aborde el problema haciendo el ejercicio en cmd y observando los resultados.



3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?


Si estoy mas cerca, me hace falta responder las otras 2 preguntas


4. ¿Qué he aprendido o reforzado en esta micro-sesión?

que el signo < se traduce como little-endian y puede cambiar el orden de como se almacena en la memoria




#### Micro-sesión 3 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

En esta micro sesion trabaje esta pregunta:

Vas a buscar qué es BIG ENDIAN y LITTLE ENDIAN.

Big Endian y Little Endian son dos formatos de ordenación de bytes utilizados para almacenar datos en la memoria de una computadora. Estos términos provienen de la novela "Los viajes de Gulliver" de Jonathan Swift, donde los personajes Liliputienses estaban divididos entre aquellos que rompían los huevos por el extremo grande (Big Endian) y aquellos que lo hacían por el extremo pequeño (Little Endian).

La diferencia entre Big Endian y Little Endian radica en el orden en que se almacenan los bytes de datos multibyte (como números enteros, números de punto flotante, etc.) en la memoria de la computadora.

Big Endian: En este formato, los bytes más significativos (el byte más grande) se almacenan primero en la dirección de memoria más baja, seguidos de los bytes menos significativos. Es decir, el byte más significativo se almacena en la posición más baja de memoria. Este es el enfoque utilizado por sistemas como el formato de red TCP/IP.

Little Endian: En este formato, los bytes menos significativos (el byte más pequeño) se almacenan primero en la dirección de memoria más baja, seguidos de los bytes más significativos. Es decir, el byte menos significativo se almacena en la posición más baja de memoria. Este es el enfoque utilizado por arquitecturas como x86 y x86-64.

2. ¿Con qué dificultades me encontré y cómo las abordé?

Estuve buscando la definiciones de estos conceptos en internet pero los articulos o las definiciones que encontraba me parecian confusos asi que procedi a preguntarle a chatgpt que me parece que es la mejor herramientab para definir conceptos.


3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

Si estoy mas cerca, me hace falta responder la ultima pregunta de la actividad


4. ¿Qué he aprendido o reforzado en esta micro-sesión?

Reforce en que mi conclusion de  BIG ENDIAN y LITTLE ENDIAN en la actividad si era correcta ya que uno almacena los datos desde el mayor y el otro desde el menor.



#### Micro-sesión 4. (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?

En el caso anterior puedes decir cuál es el ENDIAN para > y para <.

Para > es Big Endian: En este formato, los bytes más significativos (el byte más grande) se almacenan primero en la dirección de memoria más baja, seguidos de los bytes menos significativos. Es decir, el byte más significativo se almacena en la posición más baja de memoria.


Para < es Little Endian: En este formato, los bytes menos significativos (el byte más pequeño) se almacenan primero en la dirección de memoria más baja, seguidos de los bytes más significativos. Es decir, el byte menos significativo se almacena en la posición más baja de memoria.


2. ¿Con qué dificultades me encontré y cómo las abordé?

la verdad la mayor dificultad es que no entendi la pregunta muy bien, asi que lo aborde respondiendola como creo se debe responder. 


3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

Si estoy mas cerca, debo seguir realizando las actividades


4. ¿Qué he aprendido o reforzado en esta micro-sesión?

Reforce la simbologia y conceptos de los Endian. 


**Cierre de sesión:**

5. ¿He alcanzado los objetivos planteados al inicio? Si no, ¿por qué y qué puedo mejorar?




6. ¿Cuáles fueron los desafíos más significativos de hoy y cómo los superé?


7. Basado en el trabajo de hoy, ¿qué insights importantes he ganado?


8. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?



### Sesión 3

#### Micro-sesión 1 (25 minutos)

**Planeación:**

1. ¿Qué voy a trabajar hoy?

En esta sesion autonoma tengo planeado trabajar en la actividad 4 y no en la 3 porque esta la quiero dejar para hacerla en clase para poder hacer pruebas con el microbit 


2. ¿Cuál es mi objetivo principal para esta sesión?


Investigar analizar y responder las preguntas planteadas para dicha actividad.



**Meta-aprendizaje:**

3. ¿Qué he logrado en esta micro-sesión de trabajo?

En esta micro sesion empece analizando el codigo para comprenderlo mejor 


Inicialización de variables: Se declaran dos variables, port y connectBtn, que se usarán para la comunicación serial y para crear un botón de conexión, respectivamente.

Función setup(): Esta función se llama una vez al principio del programa y se utiliza para inicializar configuraciones iniciales, como el lienzo de dibujo y la creación de los elementos de la interfaz de usuario, como el botón de conexión y el botón de envío.

Función draw(): Esta función se llama repetidamente y se utiliza para dibujar y actualizar elementos en el lienzo. Aquí, se verifica si hay datos disponibles en el puerto serial. Si hay al menos 12 bytes disponibles, se leen esos bytes, se convierten en valores flotantes utilizando la función bytesToFloats() y se muestran en la pantalla. Además, el estado del botón de conexión se actualiza dependiendo de si el puerto está abierto o cerrado.

Función connectBtnClick(): Esta función se ejecuta cuando se hace clic en el botón de conexión. Si el puerto no está abierto, se intenta abrir con una velocidad de transmisión de 115200 baudios (que es una velocidad de comunicación común para comunicación serial con Arduino). Si el puerto ya está abierto, se cierra.

Función sendBtnClick(): Esta función se ejecuta cuando se hace clic en el botón de envío. Envía la cadena "Hello from p5.js" al dispositivo conectado a través del puerto serial.

Función bytesToFloats(): Esta función toma un array de bytes como entrada y devuelve un array de números flotantes. Utiliza un DataView para interpretar los bytes como flotantes de 32 bits, ya que la comunicación serial suele enviar datos en forma de bytes.



4. ¿Con qué dificultades me encontré y cómo las abordé?


Analizar paso a paso el codigo, para esto me apoye de chatgpt



5. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?


Si estoy mas cerca 


6. ¿Qué he aprendido o reforzado en esta micro-sesión?

Aprendi como funciona el codigo 



#### Micro-sesión 2 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?


En esta micro sesion logre realizar el punto 1 de la actividad 4:  Analiza detenidamente cada parte del código anterior.


Inicialización de variables:

Aquí se declaran dos variables globales para almacenar el objeto de puerto serial (port) y el botón de conexión (connectBtn). Estas variables se utilizarán más adelante en el código.



Función setup():

Esta función se llama una vez al principio del programa y se utiliza para configurar el lienzo de dibujo, crear los botones de conexión y envío, y asignar funciones de clic a estos botones. El lienzo se crea con una resolución de 400x400 píxeles y un fondo de color gris claro.


Función draw():



La función draw() se llama continuamente en un bucle y se utiliza para actualizar la interfaz de usuario y procesar datos entrantes. Aquí, se verifica si hay al menos 12 bytes disponibles en el puerto serial. Si es así, se leen esos bytes y se procesan para mostrar los datos en la pantalla. Además, el texto del botón de conexión se actualiza según el estado del puerto.


Función connectBtnClick():

Esta función se llama cuando se hace clic en el botón de conexión. Si el puerto serial no está abierto, se intenta abrir con un nombre ('MicroPython') y una velocidad de transmisión (115200 baudios) específicos. Si el puerto ya está abierto, se cierra.


Función sendBtnClick():


Esta función se ejecuta cuando se hace clic en el botón de envío. Envía la cadena "Hello from p5.js" al dispositivo conectado a través del puerto serial.


Función bytesToFloats():

Esta función toma un array de bytes como entrada y devuelve un array de números flotantes. Utiliza un DataView para interpretar los bytes como flotantes de 32 bits, ya que la comunicación serial suele enviar datos en forma de bytes.



2. ¿Con qué dificultades me encontré y cómo las abordé?


La mayor dificultad fue analizar paso a paso cada linea del codigo



3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?

si estoy mas cerca, me falta responder las otras preguntas de la actividad




4. ¿Qué he aprendido o reforzado en esta micro-sesión?

Aprendi linea a linea la funciones del codigo



#### Micro-sesión 3 (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?


En esta micro sesion trabajare en la pregunta 3 de la actividad ya que la 2 se trata de experimentar y quisiera hacerlo en clase con el microbit por lo tanto la pregunta 3 es : ¿Notaste en la función draw() la línea if(port.availableBytes() >= 12)? ¿De dónde sale ese número 12?


En la línea if (port.availableBytes() >= 12) dentro de la función draw(), se está verificando si hay al menos 12 bytes de datos disponibles para leer del puerto serial en ese momento. Esta línea es crucial porque garantiza que el código solo intente leer datos del puerto serial cuando hay suficientes datos disponibles para procesar.

El número 12 en esta línea es un valor arbitrario que se ha elegido con base en el contexto específico de la comunicación entre el código p5.js y el Arduino. Cuando se está comunicando con un dispositivo externo a través de un puerto serial, generalmente se envían datos en forma de bytes. La cantidad de bytes que se envían depende del formato de los datos y de la cantidad de información que se está transmitiendo en cada mensaje.

En este caso, el código está esperando recibir un conjunto de datos específico del Arduino que ocupa exactamente 12 bytes. Este valor puede haber sido determinado en función del tipo y la cantidad de datos que el Arduino está enviando en cada transmisión. Por ejemplo, si el Arduino está enviando tres números de punto flotante (float) de 4 bytes cada uno, entonces el tamaño total de la transmisión sería de 12 bytes (3 * 4 = 12).


2. ¿Con qué dificultades me encontré y cómo las abordé?


No me encontre con dificultades 




3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?


Si estoy mas cerca, me falta responder la 4ta pregunta para asi terminar la actividad




4. ¿Qué he aprendido o reforzado en esta micro-sesión?

Aprendi porque y como sale el numero 12 en el codigo



#### Micro-sesión 4. (25 minutos)

**Trabajo en concentración**

**Meta-aprendizaje:**

1. ¿Qué he logrado en esta micro-sesión de trabajo?


En esta micro sesion me dedique a trabajar en la pregunta 4 que es: Y si la cantidad de datos que envía el micro:bit es variable?


Si la cantidad de datos enviados por el Micro:bit es variable, entonces la condición if (port.availableBytes() >= 12) en la función draw() podría necesitar ser ajustada para manejar esta variabilidad. Aquí hay algunas opciones para abordar este escenario:

Establecer una condición basada en la cantidad mínima de bytes esperados: En lugar de verificar si hay exactamente 12 bytes disponibles, podrías cambiar la condición para verificar si hay al menos una cierta cantidad mínima de bytes disponibles para leer, lo que podría ser un número menor o mayor que 12. Por ejemplo, podrías usar algo como if (port.availableBytes() >= MIN_BYTES) donde MIN_BYTES es una variable que puedes ajustar según las necesidades de tu aplicación.

Implementar un mecanismo de delimitación de datos: Si la cantidad de datos enviados por el Micro:bit varía pero hay una manera de delimitar los datos, es decir, si hay un carácter o secuencia de caracteres específicos que indican el inicio o el fin de un conjunto de datos, podrías modificar el código para buscar estos delimitadores y leer los datos entre ellos.

Utilizar un buffer dinámico para almacenar y procesar los datos: En lugar de esperar una cantidad específica de bytes, podrías implementar un buffer dinámico donde los datos se acumulan a medida que se reciben del Micro:bit, y luego procesar esos datos cuando se haya recibido una cantidad suficiente o cuando se haya alcanzado un punto de delimitación.





2. ¿Con qué dificultades me encontré y cómo las abordé?


No tuve dificultades



3. ¿Estoy más cerca de alcanzar el objetivo de la sesión? ¿Qué falta por hacer?


Si, debo realizar las 2 actividades faltantes y asi termino la fase de investigacion



4. ¿Qué he aprendido o reforzado en esta micro-sesión?


Aprendi a como se puede realizar el codigo o programa teniendo una cantidad variable de datos



**Cierre de sesión:**

5. ¿He alcanzado los objetivos planteados al inicio? Si no, ¿por qué y qué puedo mejorar?

Si los alcance porque pude completar la actividad que habia planeado 


6. ¿Cuáles fueron los desafíos más significativos de hoy y cómo los superé?

Los desafios que tuve en cada muicro sesion los escribi y en cada una de ellas


7. Basado en el trabajo de hoy, ¿qué insights importantes he ganado?




8. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?





## Semana 11

### Sesión 1

1. ¿Cuál será el propósito de la sesión de hoy?

En esta sesion tengo planeado analizar y llevar a cabo la actividad 3 la cual es un experimento con el microbit en el cual estare usando el microcontrolador en clase para poder experimentar.

Procedi viendo los resultados que me daba en web terminal que son los seguientes 

![image](https://github.com/jfUPB/bitacorassfi12024-10-sebas890p/assets/110270011/1481b494-5705-485f-9c13-17ddae982d85)

De estos resultados puedo observar que son los mismos puntos flotantes que se trabajaron en la actividad 1 asi que a partir de esto me surgio la pregunta de si podia hacer otra estructura de datos pero que esta ves se envien cuando se presione b, asi que empece a experimentar y quedo asi:

![image](https://github.com/jfUPB/bitacorassfi12024-10-sebas890p/assets/110270011/4e842f4b-0d6c-4314-8963-2976a9937f60)

y los resultados en el serial fueron estos:

![image](https://github.com/jfUPB/bitacorassfi12024-10-sebas890p/assets/110270011/a02ba861-b060-4f1d-9d5d-0b86d836399b)


Si pude crear otra estructura de datos y enviarla con otro pulsador

 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

El desafio mas significativo de esta sesion pienso que fue entender el real funcionamiento de este codigo o mas que entender comprender lo que se puede hacer con el codigo, pude superarlo leeyendolo y experimentando para asi sacar varias conclusiones. 



3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?


 En esta sesion aprendi a como puedo mandar paquetes de estructuras de datos, que esta es la conclusion que saque de la actividad 3 que a partir de ese codigo se puede crear las estructuras de daros lo que cual sirve para limitar los datos que se envian. 



4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

Para avanzar en el proyecto debo seguir en el trabajo de investigacion analizando y haciendo las actividades para ya luego empezar a aplicar.  


### Sesión 2

1. ¿Cuál será el propósito de la sesión de hoy?

En esta sesion tengo como proposito realizar la actividad 5 sin embargo la estoy haciendo desde la casa por lo cual no podre hacer lo experimentos que quisiera con el microbit como si podria en clase por lo que deje los codigos hechos para que en la proxima clase solo sea de probarlos a ver si todo funciona bien los codigos son los siguientes:

```js

let serial;
let connectBtn;
let connected = false;

function setup() {
    createCanvas(400, 400);
    background(220);
    serial = new p5.SerialPort();
    connectBtn = createButton('Connect to Arduino');
    connectBtn.position(80, 200);
    connectBtn.mousePressed(connectBtnClick);
    let sendBtn = createButton('Send hello');
    sendBtn.position(220, 200);
    sendBtn.mousePressed(sendBtnClick);

    serial.on('data', gotData);
}

function draw() {
    if (connected) {
        if (serial.available() >= 12) {
            let arr = serial.readBytes(12);
            print(arr);
            background(220);
            const sensors = bytesToFloats(arr);
            sensor1 = sensors[0].toFixed(2);
            sensor2 = sensors[1].toFixed(2);
            sensor3 = sensors[2].toFixed(2);
            print(sensor1);
            print(sensor2);
            print(sensor3);

            text(sensor1, 10, height - 60);
            text(sensor2, 10, height - 40);
            text(sensor3, 10, height - 20);
        }
    }
    if (!connected) {
        connectBtn.html('Connect to Arduino');
    } else {
        connectBtn.html('Disconnect');
    }
}

function connectBtnClick() {
    if (!connected) {
        serial.open('MicroPython', 115200);
    } else {
        serial.close();
    }
}

function sendBtnClick() {
    if (connected) {
        serial.write("Hello from p5.js\n");
    } else {
        print("Not connected to Arduino.");
    }
}

function gotData() {
    connected = true;
}

function bytesToFloats(bytes) {
    const buffer = new Uint8Array(bytes).buffer;
    const view = new DataView(buffer);
    const floats = [];

    for (let i = 0; i < bytes.length; i += 4) {
        floats.push(view.getFloat32(i));
    }

    return floats;
}
```

```py

from microbit import *
import struct

uart.init(baudrate=115200)

BUFFER_SIZE = 12
buffer = bytearray(BUFFER_SIZE)

while True:
    if uart.any():
        uart.readinto(buffer)
        data = struct.unpack('>3f', buffer)
        display.scroll(str(data))
```


```html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serial Communication with p5.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.serialport.js"></script>
</head>
<body>
    <h1>Serial Communication with p5.js</h1>
    <p>Received Data:</p>
    <p id="receivedData"></p>

    <script>
        let serial;
        let receivedDataElement;

        function setup() {
            receivedDataElement = document.getElementById('receivedData');
            serial = new p5.SerialPort();
            serial.on('data', gotData);
            serial.open('COM3'); // Cambiar al puerto correcto
        }

        function gotData() {
            let data = serial.readBytes();
            if (data !== null) {
                let floatArray = new Float32Array(data.buffer);
                receivedDataElement.innerHTML = 'Received Data: ' + floatArray.join(', ');
            }
        }
    </script>
</body>
</html>
```


El proposito es que se pueda mandar datos binarios desde p5.js y que estos se reflejen en el microbit, en clase hare las pruebas y experimentos correspondientes. 



 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

El desafio mas signficativo fue integrar los programas en binario pero lo supere partiendo de una base con la ayuda de chat gpt y luego haciendo algunos cambios 

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

aprendi a como a integrar los programas enviando datos en binario (bytes) y como conclusion saco que es un poco parecido al ACSSI pero esta vez es todo un poco mas manual a lo que me refiero es que se debe tener cuidado con la cantidad de datos que si quiera mandar 

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

Los pasos a seguir es poder experimentar con los codigos en clase y luego sacar mas conclusiones

### Sesión 3

1. ¿Cuál será el propósito de la sesión de hoy?

El proposito de la sesion autonoma de hoy es terminar con la investigacion y por ultimo me falta dejar en claro lo siguiente :

¿Cuál es la diferencia entre el modelo de comunicación por eventos y el modelo cliente-servidor?

El modelo de comunicación por eventos y el modelo cliente-servidor son dos enfoques diferentes para gestionar la comunicación entre sistemas o componentes

Modelo de Comunicación por Eventos:

Definición:

En el modelo de comunicación por eventos, los sistemas intercambian información en respuesta a eventos específicos que ocurren en uno o más de los sistemas
Los eventos pueden ser acciones del usuario, cambios de estado en el sistema, o cualquier otra cosa que desencadene una acción en un sistema

Características:

La comunicación es asincrónica y basada en eventos.

Los sistemas pueden reaccionar a eventos y tomar acciones apropiadas en función de ellos
Los sistemas pueden emitir eventos para notificar a otros sistemas sobre cambios o acciones importantes

Ejemplo:


Un navegador web que responde a eventos del usuario como clics de ratón, pulsaciones de teclas, y cargas de página.
Un servidor de chat que envía mensajes a los clientes cuando se reciben nuevos mensajes de otros usuarios.

Modelo Cliente-Servidor:

Definición:

En el modelo cliente-servidor, los sistemas están organizados en dos roles distintos: el cliente y el servidor
El cliente solicita recursos o servicios al servidor, y el servidor responde a esas solicitudes proporcionando los recursos o servicios solicitados

Características:

La comunicación es generalmente síncrona, donde el cliente envía una solicitud al servidor y espera una respuesta
El servidor escucha las solicitudes de los clientes y responde en consecuencia
El cliente y el servidor pueden estar en diferentes dispositivos o sistemas, y se comunican a través de una red

Ejemplo:

Un navegador web (cliente) que solicita páginas web a un servidor web y muestra el contenido recibido
Una aplicación móvil (cliente) que solicita datos de un servidor de base de datos para mostrar información al usuario

Diferencias:

Tipo de Comunicación:

El modelo de comunicación por eventos se basa en la comunicación asincrónica y orientada a eventos, donde los sistemas reaccionan a eventos específicos
El modelo cliente-servidor implica comunicación síncrona, donde el cliente envía solicitudes al servidor y espera respuestas

Organización de Roles:

En el modelo de comunicación por eventos, no hay roles fijos como cliente y servidor. Los sistemas pueden actuar como emisores o receptores de eventos según sea necesario
En el modelo cliente-servidor, los sistemas están organizados en dos roles distintos: el cliente que solicita servicios y el servidor que los proporciona

Intercambio de Datos:

En el modelo de comunicación por eventos, los sistemas pueden enviar y recibir datos en respuesta a eventos específicos sin necesidad de una solicitud explícita
En el modelo cliente-servidor, los datos se intercambian en respuesta a solicitudes explícitas enviadas por el cliente al servidor y las respuestas correspondientes del servidor al cliente

 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

No tuve desafios por lo que fue pura investigacion

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

Como conclusion saco que cada modelo de comunicación por eventos y el modelo cliente-servidor depende de las necesidades específicas de la aplicación y de los requisitos de comunicación entre los sistemas o componentes involucrados. Cada modelo tiene sus propias ventajas y desventajas, y es importante seleccionar el enfoque más adecuado para cada situación particular, si embargo el modelo de comunicación por eventos ofrece la flexibilidad y la capacidad de respuesta necesarias para manejar eficazmente la comunicación binaria entre el dispositivo Micro:bit y la aplicación p5.js, especialmente cuando la comunicación es asincrónica y basada en eventos

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

Para avanzar en el proyecto debo empezar a aplicar la investigacion


## Semana 12

### Sesión 1

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí

### Sesión 2

1. ¿Cuál será el propósito de la sesión de hoy?

El proposito de esta clase es trabajar en la nueva actividad propuesta por el profesor que es la 6 la cual trabajamos junto a el 

![image](https://github.com/jfUPB/bitacorassfi12024-10-sebas890p/assets/110270011/a410a6aa-09c0-4102-b0b7-d661862ec459)

En este experimento le mandamos 3 sensores al micro bit y la idea es que recibiera 2 sensores 8 bits en total 


2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

En esta sesion no hubo desafios ya que fue una sesion dirigida por el profesor 

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

Aprendi a como enviar datos flotantes al microbit y a la vez reforzarlo con los experimentos 

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

Para seguir avanzando debo tomar lo aprendido y empezar a aplicarlo. 

### Sesión 3

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí

## Semana 13

### Sesión 1

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí

### Sesión 2

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí

### Sesión 3

1. ¿Cuál será el propósito de la sesión de hoy?

> Escribe aquí
 
2. ¿Cuáles fueron los desafíos más significativos de la sesión y cómo los superé?

> Escribe aquí

3. Basado en el trabajo de la sesión, ¿Qué aprendí o qué conclusión saco o cuál es la síntesis?

> Escribe aquí

4. ¿Cuáles son los pasos siguientes para continuar avanzando en el proyecto?

> Escribe aquí

